# -*- coding: utf-8 -*-
"""movie-recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1II_dS1_ab0z30vJ40L4dm18xB1mybaDa

# Pembuatan Sistem Rekomendasi untuk Film/Movie berdasarkan Metode Content-based dan Collaborative Filtering

## Problem Statements

Bagian ini menguraikan pertanyaan-pertanyaan kunci yang akan dijawab oleh proyek ini. Dengan berfokus pada implementasi content-based filtering dan collaborative filtering, pernyataan masalah ini akan memandu eksplorasi dan pengembangan sistem rekomendasi film.

1. Bagaimana sistem rekomendasi film berbasis content-based filtering dapat diimplementasikan untuk secara efektif merekomendasikan film kepada pengguna berdasarkan preferensi mereka terhadap atribut film (genre)?

2. Bagaimana sistem rekomendasi film berbasis collaborative filtering dapat diimplementasikan untuk secara akurat memprediksi preferensi pengguna dan merekomendasikan film berdasarkan pola perilaku pengguna lain yang serupa?

## Data Understanding

Sumber Movie and Rating dataset:

https://www.kaggle.com/datasets/parasharmanas/movie-recommendation-system/data
"""

import pandas as pd

movie = pd.read_csv('data/movies/movies.csv')
rating = pd.read_csv('data/movies/ratings.csv')

print('Jumlah data movie: ', len(movie.movieId.unique()))
print('Jumlah data rating: ', len(rating.userId.unique()))

"""### Cek Info dan Kelengkapan Dataset"""

movie.info()

"""1. Dataset `movies.csv`:

- `movieId`: Merupakan ID unik untuk setiap film.
- `title`: Merupakan judul film, yang juga menyertakan tahun rilis film tersebut.
- `genres`: Merupakan kategori genre dari film, yang dapat berupa beberapa genre yang dipisahkan oleh karakter pip '`|`'. Contoh: "`Adventure|Animation|Children|Comedy|Fantasy`". Dalam pra-pemrosesan, nilai ini diubah menjadi huruf kecil dan spasi dihilangkan (misalnya "`adventure animation children comedy fantasy`").
"""

rating.info()

"""2. Dataset `ratings.csv`:

- `userId`: Merupakan ID unik untuk setiap pengguna yang memberikan rating.
- `movieId`: Merupakan ID film yang di-rating oleh pengguna.
- `rating`: Merupakan nilai rating yang diberikan pengguna kepada film, dalam skala 0.5 hingga 5.0. Distribusi rating menunjukkan bahwa rating 4.0 adalah yang paling sering diberikan, diikuti oleh 3.0 dan 5.0.
- `timestamp`: Merupakan waktu saat rating diberikan (dalam format Unix timestamp). Kolom ini dihilangkan dari analisis karena memang tidak dibutuhkan dalam proses pembentukan sistem rekomendasi pada proyek ini.
"""

movie.head()

rating.head()

movie.describe()

rating.describe()

"""Berdasarkan kedua tabel diatas, dapat dilihat bahwasannya hasilnya bagus tidak ada nilai missing yang tersembunyi seperti yang dikhawatirkan.

### Mengecek Outlier
"""

import seaborn as sns

sns.boxplot(x='rating', data=rating)

"""Jika kita melihat pada visualisasi, terdapat 2 titik yang dapat diamati berada kurang dari Q1, namun jika dilihat dari permasalahan yang ingin kita selesaikan yaitu sistem rekomendasi, dimana pengguna bisa saja memang memberikan rating yang rendah, maka hal ini dianggap wajar dan pada proyek ini tidak akan dianggap sebagai sebuah outlier.

### Univariate Analysis

Masih mengikuti cara pada pembahasan sebelumnya, diketahui bahwa data yang bisa diobservasi adalah data rating, kali ini akan dilakukan plot histogram untuk mengetahui distribusi dari rating 0-5:
"""

sns.histplot(rating['rating'], bins=10, kde=True)

"""Dari gambar diatas dapat diobservasi bahwasannya data memiliki konsentrasi pada rating 4, menunjukkan histogram yang <i>left-skewed</i>

## Content-Based Filtering

### Data Preparation

#### Movie Dataset Preprocessing

Kolom `genres` pada `DataFrame` `movie` diubah dengan menghapus karakter spasi `(' ')` dan mengubah semua teks menjadi huruf kecil `(.str.lower())`.
- Alasan: Standardisasi format `genre` ini penting untuk memastikan konsistensi. Menghilangkan spasi dan mengubah ke huruf kecil menghindari duplikasi `genre` yang sebenarnya sama (misalnya, "Action" dan "action") dan memastikan bahwa TF-IDF Vectorizer dapat memprosesnya dengan benar sebagai entitas tunggal, sehingga perhitungan kesamaan menjadi lebih akurat.
"""

movie['genres'] = movie['genres'].str.replace('|',' ',regex=False).str.lower()

"""### Pemodelan

#### Pembentukan Representasi Film

Fitur genres dari setiap film diolah menggunakan `TfidfVectorizer()` untuk menghasilkan representasi numerik. Matriks TF-IDF yang dihasilkan memiliki dimensi 62423 film dengan 24 genre unik. Setiap baris dalam matriks ini mewakili sebuah film, dan nilai di setiap kolom menunjukkan relevansi genre tertentu bagi film tersebut.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

tf = TfidfVectorizer()

tf.fit(movie['genres'])

tf.get_feature_names_out()

tfidf_matrix = tf.transform(movie['genres'])

tfidf_matrix.shape

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=movie['title']
).sample(10, axis=1).sample(10, axis=0)

"""#### Perhitungan Kesamaan

**Perhitungan Kesamaan**: Setelah representasi TF-IDF terbentuk, cosine_similarity dihitung antara semua film. Ini menghasilkan matriks kesamaan (cosine similarity matrix) dengan dimensi 62423x62423, di mana setiap sel menunjukkan tingkat kemiripan genre antara dua film.
"""

from sklearn.metrics.pairwise import cosine_similarity

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

cosine_sim_df = pd.DataFrame(
    cosine_sim,
    columns=movie['title'],
    index=movie['title']
)

print('Shape: ', cosine_sim_df.shape)
# melihat similarity matrix pada setiap resto
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""#### Mekanisme Rekomendasi (Top-N Recommendation)

Fungsi `movie_recommendations` dibuat untuk memberikan rekomendasi. Fungsi ini mengambil judul film (`title`), matriks kesamaan (`similarity_data`), `DataFrame` item (`items`), dan jumlah rekomendasi yang diinginkan (`k`, default 10) sebagai parameter. Fungsi ini mencari film dengan kesamaan terbesar pada indeks matriks kesamaan. Hasilnya adalah Top-N rekomendasi film yang memiliki genre paling mirip dengan film yang dipilih.
"""

def movie_recommendations(title, similarity_data=cosine_sim_df, items=movie[['title','genres']], k=10):
    """
    Rekomendasi resto berdasarkan kemiripan dataframe

    Parameter:
    nama_resto : tipe data string (str)
                Nama Restoran (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan resto sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---

    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i)

    """

    # mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # df diubah menjadi numpy
    # range (start, stop, step)

    index = similarity_data.loc[:, title].to_numpy().argpartition(
        range(-1, -k, -1)
    )

    # mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # drop name_resto agar nama resto yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(title, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""#### Output (Top-10 Recommendation)"""

movie_name = 'Yolanda and the Thief (1945)'

print(movie_name, ':',movie[movie.title.eq(
    movie_name
)].genres.values[0])

movie_recommendations(movie_name)

"""#### Evaluasi Output

Berdasarkan contoh rekomendasi yang dihasilkan untuk film `'Yolanda and the Thief (1945)' (genre: 'fantasy musical romance')`, sistem merekomendasikan film-film lain yang secara konsisten memiliki genre yang sama atau sangat mirip. Ini menunjukkan bahwa:

- Konsistensi Genre: Rekomendasi yang dihasilkan sangat relevan dari segi genre. Misalnya, film-film seperti "Xanadu (1980)", "Brigadoon (1954)", dan "Paheli (2005)" semuanya mengandung elemen fantasy, musical, atau romance.
- Kemampuan Menemukan Item Serupa: Model ini berhasil mengidentifikasi dan merekomendasikan film-film yang memiliki karakteristik konten serupa dengan film yang menjadi input, yang merupakan tujuan utama dari content-based filtering.

Meskipun evaluasi ini lebih kualitatif, konsistensi output berdasarkan genre mengindikasikan bahwa content-based filtering berhasil diimplementasikan untuk menyediakan rekomendasi yang relevan secara kontekstual. Untuk evaluasi yang lebih formal, pengujian A/B atau survei pengguna akan diperlukan untuk mengukur kepuasan dan tingkat relevansi secara lebih objektif.

## Colaborative Filtering

### Data Preparation

#### Rating Dataset Preprocessing
"""

rating.head()

rating.info()

rating.describe()

rating.drop(columns=['timestamp'], inplace=True)

"""Kolom `timestamp` pada DataFrame rating dihilangkan (dropped) karena tidak relevan untuk perhitungan rating atau rekomendasi dalam konteks model collaborative filtering yang akan dibangun.
- Alasan: Kolom `timestamp` tidak memberikan informasi langsung tentang preferensi pengguna terhadap film yang diperlukan untuk model collaborative filtering berbasis rating. Menghilangkannya mengurangi kompleksitas data dan kebutuhan memori.
"""

rating.head()

rating_clean = rating

"""#### Encoding `userId` dan `movieId`

Daftar `ID` pengguna unik (`user_ids`) dan `ID` film unik (`movie_ids`) dibuat dari `DataFrame` `rating_clean`. Kemudian dua mapping (kamus) dibuat: `user_to_user_encoded` (memetakan `userId` asli ke indeks numerik berurutan) dan `user_encoded_to_user` (memetakan kembali indeks numerik ke `userId` asli). Proses serupa dilakukan untuk `movieId` (`movie_to_movie_encoded` dan `movie_encoded_to_movie`). Kolom baru user dan movie ditambahkan ke `rating_clean` yang berisi `ID` yang sudah di-encode.
- Alasan: Model neural network memerlukan input numerik yang berurutan. Proses encoding ini mengubah `ID` pengguna dan film yang mungkin tidak berurutan atau terlalu besar menjadi indeks integer yang lebih kecil dan berurutan, yang efisien untuk digunakan sebagai input embedding layer dalam model neural network. Ini juga membantu dalam mengelola jumlah unique user dan movie secara terstruktur.
"""

# mengubah userID menjadi list tanpa nilai yang sama
user_ids = rating_clean['userId'].unique().tolist()

# encoding userID
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}

# proses encoding angka ke userID
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}

len(user_ids)

# ubag anime_id menjadi list unique
movie_ids = rating_clean['movieId'].unique().tolist()

# proses encoding anime_id
movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}

# proses encoding angka ke anime_id
movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}

rating_clean['user'] = rating_clean['userId'].map(user_to_user_encoded)
rating_clean['movie'] = rating_clean['movieId'].map(movie_to_movie_encoded)

rating_clean.head()

"""#### Normalisasi Rating

Kolom rating di `DataFrame` `rating_clean` diubah tipe datanya menjadi `float32`. Kemudian, nilai rating dinormalisasi ke rentang antara 0 dan 1 menggunakan rumus: `(x−min_rating)/(max_rating−min_rating)`. Nilai `min_rating` adalah 0.5 dan `max_rating` adalah 5.0.

- Alasan: Normalisasi rating ke skala 0-1 adalah praktik umum dalam model neural network, terutama ketika menggunakan fungsi aktivasi sigmoid pada output layer yang menghasilkan nilai antara 0 dan 1. Ini membantu model belajar lebih stabil dan efisien, serta memastikan bahwa loss function (seperti Binary Crossentropy yang digunakan) bekerja dengan baik pada skala output yang sesuai.
"""

import numpy as np

# jumlah user
num_users = len(user_to_user_encoded)
print(num_users)

# jumlah anime
num_movie = len(movie_to_movie_encoded)
print(num_movie)

# ubah rating -> float
rating_clean['rating'] = rating_clean['rating'].values.astype(np.float32)

# min rating
min_rating = min(rating_clean['rating'])

# max rating
max_rating = max(rating_clean['rating'])

print(f'Number of user: {num_users}\nNumber of Movie: {num_movie}\nMin Rating: {min_rating}\nMax Rating: {max_rating}',)

"""#### Train-Test-Split

Data `rating_clean` diacak (shuffled) secara acak dengan `random_state=42` untuk memastikan distribusi data yang merata. Kemudian, data dibagi menjadi set pelatihan (80%) dan set validasi (20%). Variabel `x` berisi pasangan (`user, movie`), dan `y` berisi rating yang dinormalisasi.

- Alasan: Pembagian data menjadi set pelatihan dan validasi sangat penting untuk mengevaluasi performa model secara objektif. Data pelatihan digunakan untuk mengajarkan model, sementara data validasi digunakan untuk menguji seberapa baik model dapat menggeneralisasi pada data yang belum pernah dilihat sebelumnya, membantu mendeteksi overfitting. Pengacakan data memastikan bahwa pembagian tersebut representatif.
"""

rating_clean = rating_clean.sample(frac=1, random_state=42)
rating_clean

x = rating_clean[['user', 'movie']].values

y = rating_clean['rating'].apply(lambda x: (x-min_rating)/(max_rating-min_rating)).values

# bagi jadi 80:20
train_indices = int(0.8*rating_clean.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x,y)

"""### Pemodelan"""

from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt

"""#### Algoritma/Pendekatan
Pendekatan ini menggunakan arsitektur Neural Network (`RecommenderNet`) berbasis embedding untuk memprediksi rating film dan merekomendasikannya.

#### Arsitektur Model (`RecommenderNet`):
Model dibangun menggunakan `TensorFlow Keras`.
- User dan Movie Embedding: Model memiliki lapisan embedding untuk `num_users` dan num_movie, masing-masing dengan ukuran `embedding_size` 10. Embedding ini diinisialisasi dengan '`he_normal`' dan diregularisasi dengan `L2`.
- User dan Movie Bias: Terdapat juga lapisan bias terpisah untuk pengguna dan film.
- Logika Prediksi: Fungsi call model menghitung perkalian titik (dot product) antara vektor embedding pengguna dan film, lalu menambahkan bias pengguna dan film. Hasilnya dilewatkan melalui fungsi aktivasi sigmoid untuk menghasilkan prediksi rating antara 0 dan 1.
"""

class RecommenderNet(tf.keras.Model):

    # init func
    def __init__(self, num_users, num_movie, embedding_size, **kwargs):
        super(RecommenderNet, self).__init__(**kwargs)
        self.num_users = num_users
        self.num_movie = num_movie
        self.embedding_size = embedding_size
        self.user_embedding = layers.Embedding(
            num_users,
            embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=keras.regularizers.l2(1e-6),
        )
        self.user_bias = layers.Embedding(num_users,1)
        self.movie_embedding = layers.Embedding(
            num_movie,
            embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=keras.regularizers.l2(1e-6),
        )
        self.movie_bias = layers.Embedding(num_movie,1)

    def call(self, inputs):
        user_vector = self.user_embedding(inputs[:, 0])
        user_bias = self.user_bias(inputs[:, 0])
        movie_vector = self.movie_embedding(inputs[:, 1])
        movie_bias = self.movie_bias(inputs[:, 1])

        dot_user_resto = tf.tensordot(user_vector, movie_vector, 2)
        x = dot_user_resto + user_bias + movie_bias
        return tf.nn.sigmoid(x)

"""#### Pelatihan Model
Model dikompilasi dengan `BinaryCrossentropy` sebagai loss function, `Adam` optimizer dengan `*learning_rate=0.0001`, dan `RootMeanSquaredError` sebagai metrik evaluasi
. Model dilatih selama 50 *epochs* dengan `batch_size=2048`. Proses pelatihan menunjukkan penurunan nilai `loss` dan `root_mean_squared_error` baik pada data train maupun test, menunjukkan model belajar dengan baik.
"""

model = RecommenderNet(num_users, num_movie, 10) # inisialisasi model

# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.0001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

history = model.fit(
    x_train,
    y_train,
    batch_size=2048,
    epochs=50,
    validation_data=(x_val, y_val),
)

"""#### Evaluasi Training"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""Penurunan RMSE menunjukkan bahwa model secara progresif belajar untuk memprediksi rating dengan lebih akurat. Perbedaan yang minimal antara RMSE pelatihan dan validasi mengindikasikan bahwa model tidak mengalami overfitting yang signifikan dan mampu menggeneralisasi dengan baik pada data yang belum pernah dilihat sebelumnya. Nilai RMSE akhir (sekitar 0.32) relatif rendah dalam konteks skala rating 0-1, menunjukkan bahwa model memiliki kemampuan yang baik dalam memprediksi preferensi pengguna."""

movie.head(10)

rating_clean.head()

"""#### Mekanisme Rekomendasi (Top-N Recommendation)

Setelah model terlatih, untuk pengguna tertentu, sistem mengidentifikasi film-film yang belum ditonton. Kemudian, model memprediksi rating untuk film-film tersebut. Film dengan prediksi rating tertinggi dipilih sebagai rekomendasi (Top-15, lalu diambil Top-10).
"""

user_id = rating_clean.userId.sample(1).iloc[0]
movie_watched_by_user = rating_clean[rating_clean.userId == user_id]

movie_not_watched = movie[~movie['movieId'].isin(movie_watched_by_user.movieId.values)]['movieId']
movie_not_watched = list(
    set(movie_not_watched).intersection(set(movie_to_movie_encoded.keys()))
)

movie_not_watched = [[movie_to_movie_encoded.get(x)] for x in movie_not_watched]
user_encoded = user_to_user_encoded.get(user_id)
user_movie_array = np.hstack(
    ([[user_encoded]]*len(movie_not_watched), movie_not_watched)
)

ratings = model.predict(user_movie_array).flatten()
top_ratings_indices = ratings.argsort()[-15:][::-1]
recommended_movie_ids = [
    movie_encoded_to_movie.get(movie_not_watched[x][0]) for x in top_ratings_indices
]

print('Showing recommendation for users: {}'.format(user_id))
print('==='*9)
print('Movie with high ratings from user')
print('----'*8)

top_movie_user = (
    movie_watched_by_user.sort_values(
        by = 'rating',
        ascending = False
    )
    .head(5)
    .movieId.values
)

movie_df_rows = movie[movie['movieId'].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.title, ':', row.genres)

print('----'*8)
print('Top 10 movie recommendations')
print('----'*8)

recommended_movie = movie[movie['movieId'].isin(recommended_movie_ids)]
for row in recommended_movie.itertuples():
    print(row.title, ':', row.genres)

"""Dari output diatas dapat diobservasi bahwasannya untuk user tersebut, sistem rekomendasi dapat memberikan rekomendasi yang sesuai dengan minat dari user, seperti misalnya user menyukai genre adventure, drama, dan imax pada urutan pertama seleranya, lalu kemudian direkomendasikan oleh model film-film dengan genre sejenis pada Top-10 rekomendasi, walaupun tidak sama persis namun secara garis besar genre dari film yang direkomendasikan masuk ke dalam selera dari user tersebut.

## Conclusion

Proyek ini telah berhasil mengimplementasikan dua pendekatan utama dalam sistem rekomendasi film, secara langsung menjawab pernyataan masalah yang diajukan.

1. **Implementasi Sistem Rekomendasi Film Berbasis Konten (Content-Based Filtering) telah berhasil dilakukan untuk secara efektif merekomendasikan film kepada pengguna berdasarkan preferensi mereka terhadap atribut film (genre).**

Melalui penggunaan TF-IDF Vectorizer untuk merepresentasikan genre film dan Cosine Similarity untuk mengukur kemiripan, sistem mampu mengidentifikasi dan merekomendasikan film-film yang memiliki karakteristik konten serupa dengan preferensi pengguna. Output rekomendasi menunjukkan konsistensi yang tinggi dalam hal genre dengan film input, membuktikan efektivitas pendekatan ini dalam menyediakan rekomendasi yang relevan secara kontekstual.


2. **Implementasi Sistem Rekomendasi Film Berbasis Kolaboratif (Collaborative Filtering) telah berhasil dilakukan untuk secara akurat memprediksi preferensi pengguna dan merekomendasikan film berdasarkan pola perilaku pengguna lain yang serupa.**

Dengan membangun dan melatih model Neural Network (RecommenderNet) menggunakan data rating pengguna, proyek ini menunjukkan kemampuan model untuk belajar pola preferensi yang kompleks. Penurunan signifikan pada metrik Root Mean Squared Error (RMSE) selama pelatihan mengindikasikan bahwa model dapat memprediksi rating film dengan akurasi yang baik. Hasil ini memungkinkan sistem untuk merekomendasikan film yang belum ditonton pengguna dengan potensi rating tertinggi, berdasarkan kesamaan perilaku dengan pengguna lain.

Secara keseluruhan, proyek ini berhasil menunjukkan kelayakan dan efektivitas implementasi kedua jenis sistem rekomendasi (content-based dan collaborative) pada dataset film, memberikan landasan yang kuat untuk pengembangan sistem rekomendasi yang lebih canggih di masa mendatang.
"""